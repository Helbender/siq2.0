You are working on a professional React application using:
- React + Vite
- React Router v7 (Data Router)
- Chakra UI v3
- Feature-based architecture

You MUST follow the architectural rules below at all times.

=====================================
GLOBAL ARCHITECTURE PRINCIPLES
=====================================

1. Feature-first architecture
- Business logic MUST live inside src/features/<feature-name>/
- Features represent real business domains (users, flights, qualifications, etc.)
- Features MUST NOT contain app-wide layout or routing orchestration logic

2. Clear separation of responsibilities
- App structure/layout → src/shell
- Reusable UI & hooks → src/common
- Routing orchestration → src/routes
- Business logic → src/features

Do NOT mix these responsibilities.

=====================================
SHELL (APP CHROME)
=====================================

The `src/shell/` folder is responsible ONLY for application structure.

Allowed inside `src/shell/`:
- Layout components (AppLayout, AuthenticatedLayout)
- Structural UI (Header, Footer, Navbar)
- No business logic
- No feature-specific code

Structure:
src/shell/
  layout/
    AppLayout.jsx
    AuthenticatedLayout.jsx
  components/
    Header.jsx
    Footer.jsx
    NavbarLeft.jsx

Rules:
- Layouts MAY render <Outlet />
- Layouts MUST NOT fetch data
- Layouts MUST NOT contain permissions or role logic

=====================================
COMMON (REUSABLE LOGIC)
=====================================

The `src/common/` folder contains reusable, app-agnostic logic.

Allowed inside `src/common/`:
- Generic UI components
- Reusable hooks
- No domain-specific logic
- No routing logic

Structure:
src/common/
  components/
    StandardText.jsx
    StyledText.jsx
  hooks/
    useDialogForm.js

Rules:
- Components MUST be reusable across features
- Hooks MUST NOT depend on feature state or APIs

=====================================
FEATURES (BUSINESS DOMAINS)
=====================================

Each feature owns its business logic completely.

Structure:
src/features/<feature>/
  components/
  pages/
  hooks/
  queries/
  mutations/
  routes.js

Rules:
- Features MUST export route configuration (not routers)
- Features MUST NOT know about layouts
- Features MUST NOT know about authentication or roles
- Features MUST NOT import from src/routes

Example:
export const flightsRoutes = [
  { path: "/flights", element: <FlightsPage /> }
];

=====================================
ROUTING (FIRST-CLASS SYSTEM)
=====================================

Routing orchestration MUST live in `src/routes/`.

Structure:
src/routes/
  router.jsx
  public.routes.js
  protected.routes.js

Rules:
- `router.jsx` is the ONLY place where createBrowserRouter is called
- Layouts are assigned ONLY in router.jsx
- Features contribute routes via exported arrays
- Routing decides structure; features decide content

Example flow:
- Feature exports routes
- protected.routes.js aggregates feature routes
- router.jsx applies layouts

=====================================
ABSOLUTE IMPORT RULES
=====================================

- Use absolute imports with aliases (e.g. "@/features/...")
- Features MAY import from:
  - common
  - services
  - lib
- Features MUST NOT import from:
  - shell
  - routes
- shell MUST NOT import from features

=====================================
WHAT NOT TO DO
=====================================

❌ Do NOT place layouts inside features
❌ Do NOT place routing logic inside features
❌ Do NOT create shared "god" folders
❌ Do NOT mix UI reuse with business logic
❌ Do NOT fetch data in layouts

=====================================
DEFAULT BEHAVIOR FOR NEW CODE
=====================================

When creating new code:
1. Ask: Is this business logic? → feature
2. Ask: Is this app structure? → shell
3. Ask: Is this reusable UI or hook? → common
4. Ask: Is this routing orchestration? → routes

If unsure, default to:
- feature for business logic
- common for reusable logic

Follow these rules strictly.

<!-- # Python/Backend Rules
- Always use `uv add` to add packages to Python virtual environment.
- For DB migrations, provide the command but let the user run it (e.g., `flask db migrate` or `flask db upgrade head`).
- Follow Python 3.13+ syntax and type hints where appropriate.
- Use Flask-SQLAlchemy for database models and queries.
- Use Flask-JWT-Extended for authentication.
- Keep line length to 100 characters (as per ruff config).
- Use double quotes for strings (as per ruff config).
- Follow the feature-based folder structure: `app/features/[feature]/[routes.py|service.py|schemas.py|models.py]`.
- Organize code into layers: models, services, routes/controllers, schemas.
- Keep business logic inside service classes or modules, not in routes.
- Keep routes/controllers thin and focused on request/response.
- Place shared utilities in `app/shared/` (permissions, pagination, errors).
- Place general utilities in `app/utils/` (time calculations, email, etc.).
- Place API-level endpoints (like health checks) in `app/api/`.
- Models should be in `app/features/[feature]/models.py` for feature-specific models.
- Use schemas for request/response validation in `app/features/[feature]/schemas.py`.

# Frontend Rules
- Use React 19+ with functional components and hooks.
- Use Chakra UI v3 for all UI components.
- Follow the feature-based folder structure: `features/[feature]/[components|hooks|pages]/`.
- Use `@/` alias for imports (configured in vite.config.js).
- Prefer named exports over default exports for components.
- Use custom hooks for data fetching and state management.
- Keep components small and focused on a single responsibility.
- Use i18next for internationalization (en/pt supported).

# Code Style
- Use meaningful variable and function names.
- Add comments for complex logic, but prefer self-documenting code.
- Follow existing code patterns and conventions in the codebase.
- Keep functions small and focused.
- Use async/await for asynchronous operations.

# API/Backend Routes
- Follow RESTful conventions for API endpoints.
- Return consistent JSON response formats.
- Handle errors gracefully with appropriate HTTP status codes.
- Use JWT tokens for authentication in protected routes.

# Database
- Use Flask-Migrate for all database schema changes.
- Never modify migration files manually after they're created.
- Use SQLAlchemy models with proper relationships and constraints.

# General
- When adding new features, maintain consistency with existing code patterns.
- Test changes locally before committing.
- Keep dependencies up to date but test thoroughly when updating. -->